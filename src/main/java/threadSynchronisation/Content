##
Code the Synchronisation demo and showcase the fault
    -> [Code the Synchronisation demo without fix]
    -> [Run the code and show the inconsistency]
Tell about the issue
    -> Non Atomic operation being handled by more than one threads
    -> How does addition operation work
    -> With the above example, introduce race condition
    -> How can we avoid this race condition?
    -> Natural solution is allow only one thread to work on the shared resource at a time
    -> Introduce critical section
    -> What are the ways to create the critical section?
    -> Usage of synchronised keyword
    -> Implement the solution with synchronisation


##
Issues with synchronisation
How deos synchronised kw work in java?

1. Monitor Locks: Each object in Java is associated with a monitor, which is a mutual exclusion mechanism used for synchronization. When a thread enters a 
synchronized block or method, it attempts to acquire the monitor lock associated with the object on which the synchronization is applied.

2. Monitor Entry and Exit: When a thread enters a synchronized block or method, it attempts to acquire the monitor lock. If the lock is available 
(i.e., no other thread currently holds the lock), the thread acquires the lock and proceeds to execute the synchronized code. If the lock is not 
available (i.e., another thread holds the lock), the thread enters a blocked state and waits until the lock becomes available.

3. Release of Monitor Lock: When the thread exits the synchronized block or method, it releases the monitor lock, allowing other threads waiting to acquire 
the lock to proceed.

4. Intrinsic Lock: The monitor lock used by the synchronized keyword is sometimes referred to as the intrinsic lock or the monitor lock of the object instance. 
Each object in Java has its own intrinsic lock, and the synchronized keyword acquires and releases this lock implicitly when used at the method level or in synchronized 
blocks.

* It's problematic though due to 
    * Coarse-grained locking: When you use synchronized at the method level, it applies the lock to the entire method body. This means that if multiple 
      threads are accessing different parts of the method that don't necessarily need synchronization, they will still be serialized. This can lead to 
      reduced concurrency and performance bottlenecks, especially if the method contains both synchronized and unsynchronized blocks.
    * Lack of flexibility: Applying synchronization at the method level might not provide the fine-grained control needed in more complex scenarios. 
      For example, you might want to synchronize only a specific section of code within the method, or you might need to synchronize multiple methods 
      together as an atomic operation. Using method-level synchronization doesn't offer this level of granularity.
    * Inheritance issues: When a subclass overrides a synchronized method from its superclass, it must also explicitly declare the method as synchronized 
      if it wants to maintain the synchronization behavior. Failure to do so can lead to unexpected behavior and potential synchronization issues.

Code SychronisationIssue -- Don't code, just give an example

To address these concerns, it's often recommended to use explicit locking with synchronized blocks or to use the more flexible concurrency utilities provided 
by the java.util.concurrent package, such as Lock interfaces, ReentrantLock, ReadWriteLock, etc. which we are going to learn going forward in this tutorial

LockWithCustomObjects -- Code this

## 
Wait and notify
Introduction to wait and notify
    Now with an understanding of the synchronsation it's time to understand teh cocenpt of wait() and notify()
    <Room analogy explanation>
Code the WaitNotifyDemo


Differene between wait and sleep 
    wait() is used for inter-thread communication and synchronization, while sleep() is used for pausing the execution of a thread for a specified duration.

## Implement producer and consumer








